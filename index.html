<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Narratoscope • Editorial Computer</title>
  <link rel="icon" type="image/png" sizes="16x16" href="assets/favicon_io/favicon-16x16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="assets/favicon_io/favicon-32x32.png">
  <style>
    /* Пиксельные шрифты (офлайн). Положи файлы в assets/fonts/ */
    @font-face{font-family:'Pixel UI';src:url('assets/fonts/PixelOperator.ttf') format('truetype');font-weight:400;font-style:normal;font-display:swap}
    @font-face{font-family:'Pixel UI';src:url('assets/fonts/PixelOperator-Bold.ttf') format('truetype');font-weight:700;font-style:normal;font-display:swap}
    /* Доп. пиксельный шрифт с кириллицей */
    @font-face{font-family:'FSEX';src:url('assets/fonts/FSEX300.ttf') format('truetype');font-weight:400;font-style:normal;font-display:swap}
    /* ╔══════════════════════════════════════════════════════════════════════╗
       ║  CORE UI СТИЛИ: ВИНТАЖНЫЙ РАБОЧИЙ СТОЛ (Windows-95 вайб)            ║
       ║  Всё, что ниже, — ядро. Модули имеют собственные блоки CSS/JS.      ║
       ╚══════════════════════════════════════════════════════════════════════╝ */

    :root {
      --bg-paper: #F4F1EC;      /* warm off-white, Xerox Star style */
      --ink: #14110F;            /* softened black for UI ink/paper */
      --panel: #faf8f5;         /* базовый цвет панелей */
      --panel-dark: #000;
      --panel-light: #fff;
      --text: #14110F;
      --accent: #14110F;
      --accent-2: #14110F;
      --icon-size: 180px;
      --window-min-w: 360px;
      --window-min-h: 220px;
      --taskbar-h: 36px;
      --z-window: 10; --z-menu: 30; --z-boot: 1000; --z-password: 1001; --z-mobile-block: 1002;

      --ui-font: 'FSEX','Pixel UI','Press Start 2P', ui-monospace, "Courier New", monospace;
      --ui-font-size: 20px; /* базовый размер в окнах */
      --font-ui: 20px;           /* = --ui-font-size (для удобства) */
      --font-title: 16px;        /* заголовки окон */
      --font-icon: 26px;         /* подписи под иконками на рабочем столе */
      --font-controls: 16px;     /* кнопки/inputs внутри окон */
      --ui-line: 1.3;
    }

    html, body { height: 100%; }
    body {
      margin: 0; overflow: hidden; height: 100dvh; width: 100vw;
      background-color: var(--bg-paper);
      /* Xerox Star rectangular dithering: denser 4px × 8px unit */
      background-image: url('data:image/svg+xml;utf8,<svg width="8" height="8" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="2" height="4" fill="%23000"/><rect x="4" y="4" width="2" height="4" fill="%23000"/></svg>');
      background-size: 4px 4px;
      background-position: 0 0;
      font-family: var(--ui-font); font-size: var(--font-ui); line-height: var(--ui-line);
      color: var(--text);
      image-rendering: pixelated; image-rendering: crisp-edges;
      /* ПИКСЕЛЬНЫЙ ЧЕРНЫЙ КУРСОР */
      cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" shape-rendering="crispEdges"><path d="M1 1 L1 13 L5 9 L9 13 L11 11 L7 7 L11 3 Z" fill="black" stroke="black" stroke-width="1"/></svg>') 1 1, default;
    }

    .desktop { 
      position: relative; 
      inset: 0; 
      height: calc(100% - var(--taskbar-h)); 
      width: 100%; 
      padding: 12px; 
      box-sizing: border-box; 
      user-select: none;
      background-image: url('assets/icons/wallpaper.png');
      background-repeat: no-repeat;
      background-position: center;
      background-size: auto;
    }

    /* ИКОНКИ */
    .icon { position: absolute; width: var(--icon-size); height: var(--icon-size); display: grid; align-content: center; justify-items: center; color: #000; text-align: center; font-size: 12px; transition: transform .05s linear; cursor: pointer; }
    .icon:active { transform: scale(0.98); }

    .glyph { width: 168px; height: 168px; position: relative; image-rendering: pixelated; background-size: cover; }
    /* Если подставляем PNG — полностью прозрачный фон, используем саму картинку */
    .glyph.has-image{ background-color: transparent; background-repeat: no-repeat; background-position: center; background-size: contain; }

    /* Подпись иконки — крупнее и ближе */
    .icon .label { margin-top: 2px; padding: 2px 6px; border: 1px dashed transparent; border-radius: 0; background: transparent; color: var(--ink); text-shadow: none; line-height: 1.2; font-size: var(--font-icon); letter-spacing:.3px; }
    /* Выделение: инвертированные цвета */
    .icon.selected .label { background: var(--ink); color: #fff; border-color: var(--ink); }
    
    /* Folder file labels ONLY (scoped - does NOT affect desktop .icon .label) */
    .folder-file-label {
      text-align: center;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      overflow: hidden;
      text-overflow: ellipsis;
      word-break: break-word;
      overflow-wrap: break-word;
      max-width: 120px;
      width: 120px;
    }

    /* Контекстное меню */
    .context-menu { position: fixed; z-index: var(--z-menu); background: #fff; border: 2px solid var(--ink); min-width: 180px; font-size: var(--font-controls); }
    .context-item { padding: 8px 12px; cursor: default; }
    .context-item:hover { background: var(--ink); color:#fff; }
    .context-sep { height: 2px; background: var(--ink); margin: 4px 0; }

    /* Окна */
    .window { position: absolute; top: 80px; left: 120px; min-width: var(--window-min-w); min-height: var(--window-min-h); background: var(--bg-paper); border: 2px solid var(--ink); display: grid; grid-template-rows: 26px 1fr; z-index: var(--z-window); }
    .titlebar { 
      position: relative;
      height: 26px; 
      background-color: var(--bg-paper);
      background-image: url('data:image/svg+xml;utf8,<svg width="2" height="2" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="1" height="1" fill="%23000"/><rect x="1" y="1" width="1" height="1" fill="%23000"/></svg>');
      background-size: 2px 2px;
      padding: 0 8px; 
      display: flex;
      align-items: center;
      justify-content: flex-end;
      user-select: none; 
      cursor: move; 
      border-bottom: 1px solid var(--ink); 
    }
    .title-label {
      position: absolute;
      left: 8px;
      top: 3px;
      transform: none;
      background: #fff;
      padding: 1px 6px;
      border: 1px solid var(--ink);
      display: inline-block;
      font-weight: 700;
      font-size: var(--font-title);
      letter-spacing: .4px;
      color: var(--ink);
      white-space: nowrap;
      line-height: 1;
      -webkit-clip-path: polygon(3px 0, calc(100% - 3px) 0, calc(100% - 2px) 1px, calc(100% - 1px) 2px, 100% 3px, 100% calc(100% - 3px), calc(100% - 1px) calc(100% - 2px), calc(100% - 2px) calc(100% - 1px), calc(100% - 3px) 100%, 3px 100%, 2px calc(100% - 1px), 1px calc(100% - 2px), 0 calc(100% - 3px), 0 3px, 1px 2px, 2px 1px);
      clip-path: polygon(3px 0, calc(100% - 3px) 0, calc(100% - 2px) 1px, calc(100% - 1px) 2px, 100% 3px, 100% calc(100% - 3px), calc(100% - 1px) calc(100% - 2px), calc(100% - 2px) calc(100% - 1px), calc(100% - 3px) 100%, 3px 100%, 2px calc(100% - 1px), 1px calc(100% - 2px), 0 calc(100% - 3px), 0 3px, 1px 2px, 2px 1px);
    }
    .titlebar .buttons { display: flex; gap: 4px; }
    .titlebar button { height: 20px; width: 22px; border: 2px solid var(--ink); background: #fff; cursor: pointer; image-rendering: pixelated; font-weight: 700; line-height: 1; display:flex; align-items:center; justify-content:center; padding:0; font-family: var(--ui-font); }
    .titlebar button:hover { background: var(--ink); color: #fff; }
    .content { padding: 12px; background: var(--bg-paper); color:var(--ink); overflow: auto; }
    .resizer { position: absolute; right: 0; bottom: 0; width: 0; height: 0; border-left: 12px solid transparent; border-top: 12px solid transparent; border-right: 12px solid var(--ink); border-bottom: 12px solid var(--ink); cursor: nwse-resize; }

    /* Кнопки и формы внутри окон — ч/б пиксельный стиль */
    .content button,
    .content input[type="button"],
    .content input[type="submit"]{
      border:1px solid var(--ink); background:#fff; padding:6px 10px; cursor:pointer;
      font-family:var(--ui-font); font-size: var(--font-controls); letter-spacing:.2px; image-rendering:pixelated;
    }
    .content button:hover,
    .content input[type="button"]:hover,
    .content input[type="submit"]:hover{ background:var(--ink); color:#fff; }

    .content input[type="text"],
    .content textarea,
    .content select{
      border:1px solid var(--ink); background:var(--bg-paper); padding:6px; font-family:var(--ui-font);
      font-size: var(--font-controls); box-sizing:border-box;
      image-rendering: pixelated;
      cursor: text;
    }
    
    /* Internal UI lines - rasterized, pixel-constructed */
    .content hr {
      border: none;
      border-top: 1px solid var(--ink);
      margin: 12px 0;
      height: 0;
    }
    .content table {
      border-collapse: separate;
      border-spacing: 0;
      background: var(--bg-paper);
    }
    .content table td,
    .content table th {
      border: 1px solid var(--ink);
      background: var(--bg-paper);
    }
    .content textarea{ resize:vertical; }

    /* Статус отправки формы (пиксельный текст под кнопкой) */
    .form-status{ margin-top:8px; font-family: var(--ui-font); font-size: var(--font-controls); line-height:1.2; }
    .form-status.ok{ color:#067d00; }
    .form-status.err{ color:#9b0000; }

    /* Выравнивание символов в кнопках окна */
    .titlebar .buttons button:first-child { /* Свернуть — "—" */
      font-size: 14px; transform: translateY(-1px);
    }
    .titlebar .buttons button:last-child { /* Закрыть — "×" */
      font-size: 16px; transform: translateY(-1px);
    }

    /* Панель задач */
    .taskbar { 
      position: absolute; 
      bottom: 0; 
      left: 0; 
      right: 0; 
      height: var(--taskbar-h); 
      background-color: var(--bg-paper); 
      background-image: url('data:image/svg+xml;utf8,<svg width="2" height="2" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="1" height="1" fill="%23000"/><rect x="1" y="1" width="1" height="1" fill="%23000"/></svg>');
      background-size: 2px 2px; 
      border-top: 1px solid #000; 
      display: grid; 
      grid-template-columns: 1fr auto; 
      align-items: center; 
      gap: 8px; 
      padding: 0 8px; 
      box-sizing: border-box; 
    }
    .tasks { display: flex; gap: 6px; align-items: center; overflow: auto; }
    .task-btn { 
      height: 26px; 
      padding: 0 10px; 
      border: 1px solid var(--ink); 
      background-color: #FFFFFF;
      cursor: pointer; 
      white-space: nowrap;
    }
    .clock { padding: 0 10px; border: 1px solid var(--ink); background: #fff; }

    .start-menu{ position:absolute; left:8px; bottom:calc(var(--taskbar-h) + 4px); width:360px; background:#fff; border:2px solid var(--ink); z-index:var(--z-menu); display:grid; grid-template-rows:auto 1fr; }
    .start-head{ background:#fff; color:var(--ink); font-weight:700; padding:8px; border-bottom:2px solid var(--ink); font-size:var(--font-title); letter-spacing:.3px; }
    .start-body{ padding:12px; }
   
   /* Виджет-качалка */
    .rocker-widget{
      position:fixed; right:12px; bottom:calc(var(--taskbar-h) - 2px);
      width:160px; height:160px;
      background:transparent url('assets/ui/rocker-pixel.svg') center/contain no-repeat;
      image-rendering:pixelated; z-index:25; cursor:pointer;
      border:none; outline:none; box-shadow:none; padding:0;
      -webkit-appearance:none; appearance:none; background-color:transparent;
    }
    @keyframes rock{ 0%{ transform:rotate(-2deg);} 50%{transform:rotate(2deg);} 100%{transform:rotate(-2deg);} }
    .rocker-widget{ animation: rock 4s ease-in-out infinite; transform-origin: 50% 95%; }
    @keyframes rock{ 0%{ transform:rotate(-2deg);} 50%{transform:rotate(2deg);} 100%{transform:rotate(-2deg);} }
    .rocker-widget{ animation: rock 4s ease-in-out infinite; transform-origin: 50% 90%; }

    /* Экран ввода пароля */
    .password-screen { 
      position: fixed; 
      inset: 0; 
      background-color: var(--bg-paper); 
      background-image: url('data:image/svg+xml;utf8,<svg width="8" height="8" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="2" height="4" fill="%23000"/><rect x="4" y="4" width="2" height="4" fill="%23000"/></svg>');
      background-size: 4px 4px; 
      color: #000; 
      display: grid; 
      place-items: center; 
      z-index: var(--z-password); 
      font-family: var(--ui-font); 
      user-select: none; 
    }
    .password-box { background: #fff; border: 2px solid var(--ink); padding: 24px 32px; text-align: center; }
    .password-box h2 { margin: 0 0 16px 0; font-size: 18px; font-weight: 700; }
    .password-box p { margin: 0 0 20px 0; font-size: 14px; }
    .password-inputs { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; margin-bottom: 20px; }
    .password-inputs input { border: 2px solid var(--ink); background: #fff; padding: 8px; font-family: var(--ui-font); font-size: 14px; text-transform: capitalize; text-align: center; }
    .password-inputs input:focus { outline: 2px solid var(--ink); outline-offset: 2px; }
    .password-error { color: #9b0000; font-size: 12px; margin-top: 8px; min-height: 16px; }
    .password-box button { border: 2px solid var(--ink); background: #fff; padding: 8px 16px; cursor: pointer; font-family: var(--ui-font); font-size: 14px; font-weight: 700; }
    .password-box button:hover { background: var(--ink); color: #fff; }

    /* Загрузочный экран */
    .boot { 
      position: fixed; 
      inset: 0; 
      background-color: var(--bg-paper); 
      background-image: url('data:image/svg+xml;utf8,<svg width="8" height="8" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="2" height="4" fill="%23000"/><rect x="4" y="4" width="2" height="4" fill="%23000"/></svg>');
      background-size: 4px 4px;
      color: #000; 
      display: grid; 
      place-items: center; 
      z-index: var(--z-boot); 
      font-family: var(--ui-font), "Courier New", ui-monospace, monospace; 
      user-select: none; 
    }
    .boot .box { text-align: center; }
    .boot .bar { width: min(60vw, 560px); height: 10px; border: 2px solid var(--ink); margin-top: 12px; background: #fff; }
    .boot .bar > i { display: block; height: 100%; width: 0%; background: var(--ink); }

    .hidden { display: none !important; }
    .noselect { user-select: none; }

    /* Mobile/tablet blocker */
    .mobile-blocker {
      position: fixed;
      inset: 0;
      background-color: var(--bg-paper);
      background-image: url('data:image/svg+xml;utf8,<svg width="8" height="8" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="2" height="4" fill="%23000"/><rect x="4" y="4" width="2" height="4" fill="%23000"/></svg>');
      background-size: 4px 4px;
      color: var(--text);
      display: grid;
      place-items: center;
      z-index: var(--z-mobile-block);
      font-family: var(--ui-font);
      user-select: none;
      padding: 20px;
      box-sizing: border-box;
    }
    .mobile-blocker-box {
      background: #fff;
      border: 2px solid var(--ink);
      padding: 32px 40px;
      text-align: center;
      max-width: 500px;
    }
    .mobile-blocker-box p {
      margin: 0 0 16px 0;
      font-size: 14px;
      line-height: 1.6;
    }
    .mobile-blocker-box p:last-of-type {
      margin-bottom: 0;
    }

  </style>
</head>
<body>
  <!-- Mobile/tablet blocker -->
  <div id="mobileBlocker" class="mobile-blocker hidden">
    <div class="mobile-blocker-box">
      <p>You've reached a desktop.</p>
      <p>Files can be dragged.<br>Windows can be moved.<br>Some things are meant to be opened slowly.</p>
      <p>This space doesn't exist on phones or tablets.<br>Please come back from a desktop computer.</p>
    </div>
  </div>

  <!-- Экран ввода пароля -->
  <div id="passwordScreen" class="password-screen">
    <div class="password-box">
      <h2>Access Required</h2>
      <p>Password required to access<br>Lida Petrova's editorial computer</p>
      <div class="password-inputs">
        <input type="text" id="pwd1" placeholder="Word 1" maxlength="20" autocomplete="off">
        <input type="text" id="pwd2" placeholder="Word 2" maxlength="20" autocomplete="off">
        <input type="text" id="pwd3" placeholder="Word 3" maxlength="20" autocomplete="off">
      </div>
      <button id="passwordSubmit">Enter</button>
      <div class="password-error" id="passwordError"></div>
    </div>
  </div>

  <!-- Рабочий стол и системные элементы -->
  <div id="desktop" class="desktop" aria-label="Narratoscope Desktop"></div>

  <div class="taskbar" role="toolbar">
    <div id="taskspace" class="tasks"></div>
    <div class="clock" id="clock">--:--</div>
  </div>

  <div id="ctx" class="context-menu hidden" role="menu"></div>

  <div id="boot" class="boot hidden">
    <div class="box">
      <div>Narratoscope Editorial OS</div>
      <div>© 2025 Narratoscope—editor workstation</div>
      <div class="bar"><i id="bootbar"></i></div>
    </div>
  </div>

  <div id="startMenu" class="start-menu hidden" role="menu" aria-label="Start menu">
    <div class="start-head">Narratoscope Editorial Computer</div>
    <div class="start-body">
      <p style="font-size: 14px; margin: 0;">User: Lida Petrova</p>
    </div>
  </div>

  <script>
    /* ╔══════════════════════════════════════════════════════════════════════╗
       ║                               CORE                                  ║
       ║  • Регистрация модулей • Рендер иконок • Drag&Drop • Контекстное     ║
       ║    меню • Окна (свернуть/закрыть/resize) • Часы • Таскбар‑кнопки    ║
       ╚══════════════════════════════════════════════════════════════════════╝ */

    /* Mobile/tablet detection and blocking */
    let isMobileDevice = false;
    (function() {
      const mobileBlocker = document.getElementById('mobileBlocker');
      
      function isMobileOrTablet() {
        // Check for coarse pointer (touch devices)
        if (window.matchMedia('(pointer: coarse)').matches) {
          return true;
        }
        // Check for small screen size
        if (window.innerWidth < 768 || window.innerHeight < 600) {
          return true;
        }
        // Check for touch capability
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
          // But allow if screen is large enough (tablets in landscape)
          if (window.innerWidth >= 1024 && window.innerHeight >= 768) {
            return false;
          }
          return true;
        }
        return false;
      }
      
      if (isMobileOrTablet()) {
        isMobileDevice = true;
        mobileBlocker.classList.remove('hidden');
        // Hide all other UI elements
        document.getElementById('passwordScreen').classList.add('hidden');
        document.getElementById('desktop').style.display = 'none';
        document.querySelector('.taskbar').style.display = 'none';
        return;
      }
      
      // Hide blocker if desktop
      mobileBlocker.classList.add('hidden');
    })();
    
    // Skip all initialization if mobile device
    if (!isMobileDevice) {

    /* ===== Обои рабочего стола =====
       Dithering паттерн уже применен в CSS body */
function applyWallpaper(){
      // Паттерн применяется через CSS, функция оставлена для совместимости
    }
    function nextWallpaper(){ 
      // Один паттерн, переключение не требуется
    }

const DesktopCore = (() => {
      const desktop = document.getElementById('desktop');
      const taskspace = document.getElementById('taskspace');
      const ctx = document.getElementById('ctx');
      const clock = document.getElementById('clock');

      const registry = new Map();         // id -> module API
      const iconState = new Map();        // id -> {x,y}
      const windows = new Map();          // winId -> {el, taskBtn, minimized}

      const uid = () => Math.random().toString(36).slice(2, 9);
      const bringToFront = (el) => {
        let maxZ = 10; document.querySelectorAll('.window').forEach(w => {
          const z = parseInt(getComputedStyle(w).zIndex || 10, 10); if (z > maxZ) maxZ = z; });
        el.style.zIndex = maxZ + 1; };

      /* Часы */
      const tickClock = () => { const n = new Date(); clock.textContent = `${String(n.getHours()).padStart(2,'0')}:${String(n.getMinutes()).padStart(2,'0')}`; };
      setInterval(tickClock, 1000); tickClock();


      /* Контекстное меню */
      let ctxTarget = null;
      const hideContext = () => { ctx.classList.add('hidden'); ctxTarget = null; };
      const showContext = (x, y, items, target=null) => {
        ctx.innerHTML = '';
        items.forEach(item => {
          if (item === 'sep') { const s = document.createElement('div'); s.className = 'context-sep'; ctx.appendChild(s); return; }
          const d = document.createElement('div'); d.className = 'context-item'; d.textContent = item.label;
          d.addEventListener('click', () => { item.action?.(target); hideContext(); }); ctx.appendChild(d);
        });
        const { innerWidth, innerHeight } = window;
        ctx.style.left = Math.min(x, innerWidth - 180) + 'px';
        ctx.style.top  = Math.min(y, innerHeight - 120) + 'px';
        ctx.classList.remove('hidden');
        ctxTarget = target;
      };
      document.addEventListener('click', (e) => { if (!ctx.contains(e.target)) hideContext(); });

      /* Таскбар-кнопки */
      const createTaskButton = (winEl, title) => {
        const b = document.createElement('button'); b.className = 'task-btn'; b.textContent = title;
        b.addEventListener('click', () => {
          const info = windows.get(winEl.dataset.winId); if (!info) return;
          if (info.minimized) { info.el.classList.remove('hidden'); info.minimized = false; bringToFront(info.el); }
          else { bringToFront(info.el); }
        }); taskspace.appendChild(b); return b; };

      /* Окна */
      const createWindow = ({ title = 'Окно', content, width = 760, height = 520 }={}) => {
        const w = document.createElement('div'); w.className = 'window';
        w.style.width = width + 'px'; w.style.height = height + 'px'; w.dataset.winId = uid();

        // Центрируем новое окно на рабочем столе
        const dRect = desktop.getBoundingClientRect();
        const left = Math.max(12, Math.round((dRect.width  - width)  / 2));
        const top  = Math.max(12, Math.round((dRect.height - height) / 2));
        w.style.left = left + 'px';
        w.style.top  = top  + 'px';

        const tb = document.createElement('div'); tb.className = 'titlebar';
        const titleLabel = document.createElement('div'); titleLabel.className = 'title-label'; titleLabel.textContent = title;
        tb.appendChild(titleLabel);
        const btns = document.createElement('div'); btns.className = 'buttons';
        const min = document.createElement('button'); min.title = 'Свернуть'; min.textContent = '—';
        const close = document.createElement('button'); close.title = 'Закрыть'; close.textContent = '×';
        btns.appendChild(min); btns.appendChild(close); tb.appendChild(btns); w.appendChild(tb);

        const cont = document.createElement('div'); cont.className = 'content';
        if (typeof content === 'string') cont.innerHTML = content; else if (content instanceof Node) cont.appendChild(content);
        w.appendChild(cont);

        const rz = document.createElement('div'); rz.className = 'resizer'; w.appendChild(rz);

        /* Перетаскивание */
        let ox=0, oy=0, dragging=false;
        tb.addEventListener('mousedown', (e) => { dragging = true; bringToFront(w); const r = w.getBoundingClientRect(); ox = e.clientX - r.left; oy = e.clientY - r.top; document.body.classList.add('noselect'); });
        window.addEventListener('mousemove', (e) => { if (!dragging) return; w.style.left = (e.clientX - ox) + 'px'; w.style.top = (e.clientY - oy) + 'px'; });
        window.addEventListener('mouseup', () => { dragging = false; document.body.classList.remove('noselect'); });

        /* Resize */
        let resizing=false, rx=0, ry=0, startW=0, startH=0;
        rz.addEventListener('mousedown', (e)=>{ resizing = true; bringToFront(w); rx = e.clientX; ry = e.clientY; const r = w.getBoundingClientRect(); startW = r.width; startH = r.height; document.body.classList.add('noselect'); });
        window.addEventListener('mousemove', (e)=>{ if (!resizing) return; const root = getComputedStyle(document.documentElement); const minW = parseInt(root.getPropertyValue('--window-min-w')); const minH = parseInt(root.getPropertyValue('--window-min-h')); const nw = Math.max(startW + (e.clientX - rx), minW); const nh = Math.max(startH + (e.clientY - ry), minH); w.style.width = nw + 'px'; w.style.height = nh + 'px'; });
        window.addEventListener('mouseup', ()=>{ resizing=false; document.body.classList.remove('noselect'); });

        /* Кнопки */
        const taskBtn = createTaskButton(w, title);
        min.addEventListener('click', () => { w.classList.add('hidden'); const info = windows.get(w.dataset.winId); if (info) info.minimized = true; });
        close.addEventListener('click', () => { const id = w.dataset.winId; const info = windows.get(id); info?.taskBtn?.remove(); windows.delete(id); w.remove(); });

        w.addEventListener('mousedown', () => bringToFront(w));
        desktop.appendChild(w); bringToFront(w);
        windows.set(w.dataset.winId, { el: w, taskBtn, minimized: false });
        return w;
      };

      /* Иконки */
      const createIcon = ({ id, title, className='', iconUrl, x=20, y=20, onOpen, contextItems }) => {
        const el = document.createElement('div'); el.className = 'icon'; el.style.left = x + 'px'; el.style.top = y + 'px'; el.dataset.id = id;
        const g = document.createElement('div'); g.className = 'glyph ' + className; if (iconUrl) { g.classList.add('has-image'); g.style.backgroundImage = `url('${iconUrl}')`; } el.appendChild(g);
        const lab = document.createElement('div'); lab.className = 'label'; lab.textContent = title; el.appendChild(lab);

        el.addEventListener('click', () => { document.querySelectorAll('.icon').forEach(i => i.classList.remove('selected')); el.classList.add('selected'); });

        let lastClick = 0; el.addEventListener('mouseup', () => { const now = Date.now(); if (now - lastClick < 300) { onOpen?.(); } lastClick = now; });

        /* Drag&Drop */
        let dragging=false, dx=0, dy=0;
        el.addEventListener('mousedown', (e) => { if (e.button !== 0) return; dragging = true; dx = e.clientX - el.offsetLeft; dy = e.clientY - el.offsetTop; });
        window.addEventListener('mousemove', (e) => { if (!dragging) return; el.style.left = (e.clientX - dx) + 'px'; el.style.top = (e.clientY - dy) + 'px'; });
        window.addEventListener('mouseup', () => { if (!dragging) return; dragging = false; iconState.set(id, { x: el.offsetLeft, y: el.offsetTop }); });

        el.addEventListener('contextmenu', (e) => { e.preventDefault(); e.stopPropagation(); const items = contextItems ? contextItems() : defaultIconMenu(onOpen); showContext(e.clientX, e.clientY, items, el); });

        desktop.appendChild(el); return el; };

      const defaultIconMenu = (onOpen) => ([ { label: 'Open', action: () => onOpen?.() } ]);

      /* ===== Обои ===== */
      const wallpapers = ['wallpaper.png', 'wallpaper_1.png', 'wallpaper_3.png'];
      let currentWallpaperIndex = 0;
      
      function changeWallpaper() {
        currentWallpaperIndex = (currentWallpaperIndex + 1) % wallpapers.length;
        desktop.style.backgroundImage = `url('assets/icons/${wallpapers[currentWallpaperIndex]}')`;
      }
      
      /* ПКМ по рабочему столу: change wallpaper */
      desktop.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        showContext(e.clientX, e.clientY, [
          { label: 'Change wallpaper', action: () => changeWallpaper() },
        ]);
      });

      /* Text file template system */
      function renderTextFile(content, filename) {
        // Simple HTML escape
        const escapeHtml = (text) => {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        };
        
        // Determine template based on filename
        let template = 'system'; // default
        const name = filename.toLowerCase();
        
        if (name.includes('cheat') || name.includes('publishing') || name.includes('draft') || name.includes('dnd')) {
          template = 'editorial';
        } else if (name.includes('notes_from') || (name.includes('note') && name.includes('other'))) {
          template = 'found';
        } else if (name.includes('printer') || name.includes('setup') || name.includes('do_not_open')) {
          template = 'system';
        }
        
        // System note: utilitarian, monospace, tight
        if (template === 'system') {
          return `<pre style="white-space: pre-wrap; font-family: var(--ui-font); font-size: 13px; line-height: 1.4; margin: 0; padding: 12px;">${escapeHtml(content)}</pre>`;
        }
        
        // Editorial draft: more airy, margins, headings
        if (template === 'editorial') {
          // Convert ALL CAPS lines to headings
          const lines = content.split('\n');
          const processed = lines.map(line => {
            const trimmed = line.trim();
            const escaped = escapeHtml(line);
            // If line is ALL CAPS and not empty, make it a heading
            if (trimmed && trimmed === trimmed.toUpperCase() && trimmed.match(/^[A-Z\s\d\-—–]+$/)) {
              return `<div style="font-weight: 700; font-size: 16px; margin-top: 20px; margin-bottom: 8px; letter-spacing: 0.5px;">${escaped}</div>`;
            }
            return line ? `<div style="margin-bottom: 4px;">${escaped}</div>` : '<div style="height: 8px;"></div>';
          }).join('');
          return `<div style="font-family: var(--ui-font); font-size: 14px; line-height: 1.8; padding: 24px 32px; max-width: 600px; margin: 0 auto;">${processed}</div>`;
        }
        
        // Found note: handmade vibe, spacing, rules
        if (template === 'found') {
          const lines = content.split('\n');
          const processed = lines.map((line, i) => {
            if (!line.trim() && i > 0 && i < lines.length - 1) {
              return '<div style="height: 16px; border-bottom: 1px dotted var(--ink); margin: 12px 0;"></div>';
            }
            const escaped = escapeHtml(line);
            return line ? `<div style="margin: 8px 0; padding-left: 16px; position: relative;">${escaped}</div>` : '<div style="height: 12px;"></div>';
          }).join('');
          return `<div style="font-family: var(--ui-font); font-size: 14px; line-height: 1.9; padding: 20px 28px;">${processed}</div>`;
        }
        
        // Fallback
        return `<pre style="white-space: pre-wrap; font-family: var(--ui-font); font-size: 14px; line-height: 1.6;">${escapeHtml(content)}</pre>`;
      }

      /* API ядра */
      function openModule(id){ const mod = registry.get(id); mod?.onOpen?.(); }
      return { register(def) { if (!def?.id) throw new Error('Модуль без id!'); registry.set(def.id, def); }, spawnWindow: createWindow, spawnIcon(def) { return createIcon(def); }, getIconPosition(id, fb) { return iconState.get(id) || fb; }, showContext, hideContext, get registry() { return registry; }, openModule, renderTextFile };
    })();

    /* ╔══════════════════════════════════════════════════════════════════════╗
       ║                         МОДУЛИ (plug‑and‑play)                       ║
       ╚══════════════════════════════════════════════════════════════════════╝ */

    /* МОДУЛЬ: My Computer */
    DesktopCore.register({ id: 'my-computer', title: 'My Computer', iconClass: '', iconUrl: 'assets/icons/my-computer.png',
      onOpen() {
        const content = `<div style="font-family: var(--ui-font); font-size: 14px; line-height: 1.6;">
          <p><b>System:</b> Narratoscope Editorial OS</p>
          <p style="display: flex; justify-content: space-between; align-items: center;"><span><b>User:</b> Lida Petrova</span><img src="assets/Lida.png" style="width: 3em; height: 3em; display: block; image-rendering: pixelated; flex-shrink: 0;" alt="Avatar"></p>
          <br>
          <p><b>Free disk space:</b> 312 MB</p>
          <p><b>Last backup:</b> unknown</p>
          <br>
          <p><b>Note to self:</b></p>
          <p style="margin-left: 20px; font-style: italic;">(empty)</p>
        </div>`;
        DesktopCore.spawnWindow({ title: 'My Computer', width: 500, height: 380, content: content });
      }
    });

    /* МОДУЛЬ: Drafts (папка с текстовыми файлами) */
    DesktopCore.register({ id: 'drafts', title: 'Drafts', iconClass: '', iconUrl: 'assets/icons/notes.png',
  onOpen() {
    const wrap = document.createElement('div');
    const grid = document.createElement('div');
    grid.style.display = 'grid';
    grid.style.gridTemplateColumns = 'repeat(auto-fill, 120px)';
    grid.style.gap = '16px';

        const draftsFiles = [
          {
            name: 'DnD_character_draft.txt',
            content: `D&D character draft

Name: Elian Frost
Race: Half-Elf
Class: Ranger (maybe multiclass later)

Alignment:
Neutral Good (leaning chaotic when tired)

Background:
Cartographer
— good with maps
— bad with destinations

Personality:
• notices small details
• avoids leadership but ends up there
• trusts intuition over plans

Flaws:
• overthinks
• slow to act
• hates unfinished stories

Note:
give him a reason to stay.`
          },
          {
            name: 'printer_setup_notes.pdf',
            content: `PRINTING NOTES

• CMYK, not RGB
• Rich black only for large areas
• Text: 100% K

Paper:
— uncoated feels better
— slightly yellow > pure white

Margins:
— inner margin larger (binding!)
— check bleed twice

Before sending to print:
1. export PDF/X-1a
2. check fonts embedded
3. spellcheck titles manually`
          },
          {
            name: 'notes_from_other_magazines.txt',
            content: `Things I like elsewhere:

• courage to be boring
• space for silence
• trusting the reader

Things I don't:
• performative cleverness
• fake intimacy`
          }
        ];

        draftsFiles.forEach(file => {
        const cell = document.createElement('div');
        cell.style.width = '120px';
        cell.style.textAlign = 'center';
        cell.style.userSelect = 'none';
          cell.style.cursor = 'pointer';

        const ico = document.createElement('div');
        ico.style.width = '96px';
        ico.style.height = '96px';
        ico.style.margin = '0 auto';
          ico.style.backgroundImage = `url('assets/icons/txt.png')`;
        ico.style.backgroundRepeat = 'no-repeat';
        ico.style.backgroundPosition = 'center';
        ico.style.backgroundSize = 'contain';
        ico.style.imageRendering = 'pixelated';

        const cap = document.createElement('div');
          cap.textContent = file.name;
          cap.className = 'folder-file-label';
        cap.style.marginTop = '6px';
          cap.style.fontSize = '12px';

          cell.addEventListener('dblclick', () => {
            DesktopCore.spawnWindow({
              title: file.name,
              width: 640,
              height: 460,
              content: DesktopCore.renderTextFile(file.content, file.name)
            });
          });

        cell.appendChild(ico);
        cell.appendChild(cap);
        grid.appendChild(cell);
      });

    wrap.appendChild(grid);
        DesktopCore.spawnWindow({ title: 'Drafts', width: 520, height: 420, content: wrap });
      }
    });

    /* МОДУЛЬ: Expenses.xlsx */
    DesktopCore.register({ id: 'expenses', title: 'Expenses.xlsx', iconClass: '', iconUrl: 'assets/icons/price.png',
    onOpen() {
        const content = `<div style="font-family: var(--ui-font); font-size: 14px;">
          <table border="1" cellspacing="0" cellpadding="8" style="width: 100%; border-collapse: separate; border-spacing: 0; background: var(--bg-paper);">
            <tr style="background: #e0e0e0; font-weight: 700;">
              <th style="text-align: left; border: 1px solid var(--ink);">Item</th>
              <th style="text-align: left; border: 1px solid var(--ink);">Cost</th>
              <th style="text-align: left; border: 1px solid var(--ink);">Notes</th>
            </tr>
            <tr>
              <td style="border: 1px solid var(--ink);">Printing (test run)</td>
              <td style="border: 1px solid var(--ink);">$420</td>
              <td style="border: 1px solid var(--ink);">cheaper paper</td>
            </tr>
            <tr>
              <td style="border: 1px solid var(--ink);">Hosting</td>
              <td style="border: 1px solid var(--ink);">$12/month</td>
              <td style="border: 1px solid var(--ink);">temporary</td>
            </tr>
            <tr>
              <td style="border: 1px solid var(--ink);">Illustrator advance</td>
              <td style="border: 1px solid var(--ink);">$150</td>
              <td style="border: 1px solid var(--ink);">owes us favours</td>
            </tr>
            <tr>
              <td style="border: 1px solid var(--ink);">Coffee</td>
              <td style="border: 1px solid var(--ink);">$67</td>
              <td style="border: 1px solid var(--ink);">non-negotiable</td>
            </tr>
            <tr>
              <td style="border: 1px solid var(--ink);">Emergency fund</td>
              <td style="border: 1px solid var(--ink);">$0</td>
              <td style="border: 1px solid var(--ink);"></td>
            </tr>
          </table>
          <p style="margin-top: 16px; font-style: italic;">We are absolutely not ready.<br>Proceeding anyway.</p>
        </div>`;
        DesktopCore.spawnWindow({ title: 'Expenses.xlsx', width: 600, height: 400, content: content });
      }
    });

    /* МОДУЛЬ: do_not_open.txt */
    DesktopCore.register({ id: 'do-not-open', title: 'do_not_open.txt', iconClass: '', iconUrl: 'assets/icons/txt.png',
      onOpen() {
        const content = DesktopCore.renderTextFile('You opened it anyway.\n\n', 'do_not_open.txt');
        DesktopCore.spawnWindow({ title: 'do_not_open.txt', width: 640, height: 460, content: content });
      }
    });

    /* МОДУЛЬ: PUBLISHING_CHEAT_SHEET.txt */
    DesktopCore.register({ id: 'publishing-cheat-sheet', title: 'CHEAT_SHEET.txt', iconClass: '', iconUrl: 'assets/icons/txt.png',
onOpen() {
        const content = DesktopCore.renderTextFile(`PUBLISHING CHEAT SHEET
(for when my brain is tired)

QUOTATION MARKS
English:
"double quotes" — default
'single quotes' — quotes inside quotes

French:
« guillemets »
(use spaces inside)

Russian:
«ёлочки», then „лапки"

— Do NOT mix styles inside one text.

DASHES
Hyphen (-)
— for compound words (well-known)

En dash (–)
— ranges: 1998–2004

Em dash (—)
— interruptions, pauses
— no spaces in US style
— spaces optional in UK style

ELLIPSIS
…
Not three dots.
Ever.

AMPERSAND (&)
— use only in names, brands, headers
— never in running text

ITALICS
— foreign words (sparingly)
— internal thoughts (sparingly)
— titles of books

CAPITALS
— don't shout
— if everything is important, nothing is

RULE OF THUMB
If the typography is invisible,
it's working.`, 'PUBLISHING_CHEAT_SHEET.txt');
        DesktopCore.spawnWindow({ title: 'PUBLISHING_CHEAT_SHEET.txt', width: 640, height: 460, content: content });
      }
    });

    /* МОДУЛЬ: Mailbox */
    DesktopCore.register({ id: 'inbox', title: 'Mailbox', iconClass: '', iconUrl: 'assets/icons/contacts.png',
      onOpen() {
        // Pinned demo message (always shown first in Outbox, client-side only)
        const PINNED_OUTBOX_MESSAGE = {
          id: 'pinned_demo',
          from: 'Lida (Narratoscope)',
          to: 'hello@bookflix.ru',
          subject: 'I shouldn\'t be here, but…',
          body: `Hi Bookflix,

I used Lida's mailbox to write this,
which feels slightly illegal and completely appropriate.

The issue is stunning.

Please keep doing whatever this is.

— a reader`,
          date: new Date().toISOString()
        };

        const INBOX_READ_STATE_KEY = 'narratoscope_inbox_read';

        async function getOutboxMessages() {
          try {
            const response = await fetch('/api/outbox');
            if (!response.ok) {
              throw new Error(`Server returned ${response.status}`);
            }
            const data = await response.json();
            if (data.ok && Array.isArray(data.messages)) {
              // Ensure every message has a valid ISO date string
              return data.messages.map(msg => {
                if (!msg.date || isNaN(new Date(msg.date).getTime())) {
                  msg.date = new Date().toISOString();
                }
                return msg;
              });
            }
            return [];
          } catch(e) {
            console.error('Failed to fetch Outbox:', e);
            return [];
          }
        }

        async function saveOutboxMessage(message) {
          try {
            // Ensure message has a valid ISO date string
            const messageWithDate = {
              ...message,
              date: message.date || new Date().toISOString()
            };
            const response = await fetch('/api/outbox', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ message: messageWithDate })
            });
            if (!response.ok) {
              throw new Error(`Server returned ${response.status}`);
            }
            const data = await response.json();
            return data.ok;
          } catch(e) {
            console.error('Failed to save Outbox message:', e);
            throw e;
          }
        }

        function getReadState() {
          try {
            const stored = localStorage.getItem(INBOX_READ_STATE_KEY);
            return stored ? JSON.parse(stored) : {};
          } catch(e) {
            return {};
          }
        }

        function markAsRead(messageId) {
          const readState = getReadState();
          readState[messageId] = true;
          try {
            localStorage.setItem(INBOX_READ_STATE_KEY, JSON.stringify(readState));
          } catch(e) {}
        }

        // Inbox messages (local seed) - ordered as specified in TODO.md
        const inboxMessages = [
          {
            id: 'rodion_new',
            from: 'Rodion',
            to: 'Lida',
            subject: 'So what do you think?',
            body: `Lida,

I've been re-reading the issue tonight and I can't decide
whether we actually pulled it off or just convinced ourselves we did.

It feels right.

I'd really like to know what you think.

Write back when you have a moment.

— R.`,
            date: new Date(Date.now() - 3600000).toISOString(), // 1 hour ago
            unread: true
          },
          {
            id: 'print_quote',
            from: 'print@offset-press.local',
            to: 'Lida',
            subject: 'Quote request: 76 pages, full color',
            body: `Hello,

Following up on your request.

• 76 pages
• Full color
• Matte lamination cover
• Paper with "book-like feel" (please clarify)

We can offer several paper options depending on budget.

Please confirm quantity and deadline.`,
            date: new Date(Date.now() - 86400000 * 2).toISOString(), // 2 days ago
            unread: false
          },
          {
            id: 'print_clarify',
            from: 'print@offset-press.local',
            to: 'Lida',
            subject: 'Re: paper clarification',
            body: `By "book-like" do you mean:

— uncoated offset
— slightly yellowed
— visible fiber

Please note: this will increase cost slightly
but improve tactile perception.`,
            date: new Date(Date.now() - 86400000 * 1.5).toISOString(), // 1.5 days ago
            unread: false
          },
          {
            id: 'auctions',
            from: 'auctions@rare-objects.net',
            to: 'Lida',
            subject: 'About lot #311 — fountain pen',
            body: `Hello,

You asked about the provenance of the item listed as
"Virginia Woolf's fountain pen".

We can confirm the pen belonged to the Woolf household.
Direct authorship cannot be guaranteed.

Let us know if you'd like to proceed.`,
            date: new Date(Date.now() - 86400000 * 4).toISOString(), // 4 days ago
            unread: false
          },
          {
            id: 'rodion_old',
            from: 'Rodion Emelyanov',
            to: 'Lida',
            subject: 'Checking in (and maybe interfering)',
            body: `Lida,

How is it going on your side?
You mentioned the working title was Narratoscope —
are you still calling it that, or did it mutate into something else?

We're sketching ideas for our next Bookflix issue,
and I keep running into the same wall you described:
about readers being lenses.

If you're open to it, I'd love to try working on something together.
No pitch, no plan yet — just curiosity.

Let me know how the launch is going.
Or how it feels, which might be more important.

— R.`,
            date: new Date(Date.now() - 86400000 * 5).toISOString(), // 5 days ago
            unread: false
          },
          {
            id: 'contributors',
            from: 'contributors@freelance.pool',
            to: 'Lida',
            subject: 'About deadlines',
            body: `Hi Lida,

Just wanted to double-check the timeline.

Are we still aiming for "soon", or has "soon"
quietly turned into "whenever this makes sense"?

No pressure — just trying to plan my life
around a magazine that may or may not exist yet.

Best,
A.`,
            date: new Date(Date.now() - 86400000 * 6).toISOString(), // 6 days ago
            unread: false
          }
        ];

        // Apply read state from storage
        const readState = getReadState();
        inboxMessages.forEach(msg => {
          if (readState[msg.id]) {
            msg.unread = false;
          }
        });

        // Create Mailbox UI
        const wrap = document.createElement('div');
        wrap.style.fontFamily = 'var(--ui-font)';
        wrap.style.fontSize = '14px';
        wrap.style.display = 'flex';
        wrap.style.height = '100%';
        wrap.style.overflow = 'hidden';

        // Left sidebar: Folders
        const sidebar = document.createElement('div');
        sidebar.style.width = '160px';
        sidebar.style.borderRight = '1px solid var(--ink)';
        sidebar.style.padding = '12px';
        sidebar.style.display = 'flex';
        sidebar.style.flexDirection = 'column';
        sidebar.style.gap = '8px';
        sidebar.style.background = 'var(--bg-paper)';

        const inboxBtn = document.createElement('button');
        inboxBtn.textContent = 'Inbox';
        inboxBtn.style.cssText = 'border: 1px solid var(--ink); background: var(--bg-paper); padding: 8px; cursor: pointer; font-family: var(--ui-font); font-size: 14px; text-align: left; font-weight: 700;';
        
        const outboxBtn = document.createElement('button');
        outboxBtn.textContent = 'Outbox';
        outboxBtn.style.cssText = 'border: 1px solid var(--ink); background: var(--bg-paper); padding: 8px; cursor: pointer; font-family: var(--ui-font); font-size: 14px; text-align: left;';

        sidebar.appendChild(inboxBtn);
        sidebar.appendChild(outboxBtn);

        // Right side: Message list + Reading pane
        const rightPanel = document.createElement('div');
        rightPanel.style.flex = '1';
        rightPanel.style.display = 'flex';
        rightPanel.style.flexDirection = 'column';
        rightPanel.style.overflow = 'hidden';

        // Message list
        const messageList = document.createElement('div');
        messageList.style.flex = '0 0 30%';
        messageList.style.minHeight = '0';
        messageList.style.overflowY = 'auto';
        messageList.style.background = 'var(--bg-paper)';

        // Divider bar
        const divider = document.createElement('div');
        divider.style.height = '16px';
        divider.style.flexShrink = '0';
        divider.style.background = '#E8E5E0';
        divider.style.borderTop = '1px solid var(--ink)';
        divider.style.borderBottom = '1px solid var(--ink)';

        // Reading pane
        const readingPane = document.createElement('div');
        readingPane.style.flex = '1';
        readingPane.style.minHeight = '0';
        readingPane.style.display = 'flex';
        readingPane.style.flexDirection = 'column';
        readingPane.style.background = 'var(--bg-paper)';

        rightPanel.appendChild(messageList);
        rightPanel.appendChild(divider);
        rightPanel.appendChild(readingPane);

        wrap.appendChild(sidebar);
        wrap.appendChild(rightPanel);

        let currentFolder = 'inbox';
        let selectedMessage = null;

        function updateUnreadBadge() {
          const unreadCount = inboxMessages.filter(m => m.unread).length;
          inboxBtn.textContent = unreadCount > 0 ? `Inbox (${unreadCount})` : 'Inbox';
        }

        async function renderMessageList(folder) {
          messageList.innerHTML = '';
          
          let messages;
          if (folder === 'inbox') {
            messages = inboxMessages;
          } else {
            // Outbox: combine pinned message + server messages
            const serverMessages = await getOutboxMessages();
            messages = [PINNED_OUTBOX_MESSAGE, ...serverMessages];
          }

          if (messages.length === 0) {
            const empty = document.createElement('div');
            empty.style.padding = '20px';
            empty.style.textAlign = 'center';
            empty.style.color = 'var(--ink)';
            empty.textContent = 'No messages.';
            messageList.appendChild(empty);
            return;
          }

          messages.forEach((msg) => {
            const item = document.createElement('div');
            item.style.cssText = 'padding: 10px; border-bottom: 1px solid var(--ink); cursor: pointer; background: ' + (selectedMessage?.id === msg.id ? '#E8E5E0' : 'var(--bg-paper)') + ';';
            
            const from = document.createElement('div');
            from.style.fontWeight = folder === 'inbox' && msg.unread ? '700' : '400';
            from.textContent = folder === 'inbox' ? msg.from : msg.to;
            
            const subject = document.createElement('div');
            subject.style.fontSize = '12px';
            subject.style.marginTop = '4px';
            subject.style.color = 'var(--ink)';
            subject.textContent = msg.subject || '(no subject)';
            
            const date = document.createElement('div');
            date.style.fontSize = '11px';
            date.style.marginTop = '4px';
            date.style.color = 'var(--ink)';
            const msgDate = new Date(msg.date || new Date().toISOString());
            if (isNaN(msgDate.getTime())) {
              const fallbackDate = new Date();
              date.textContent = fallbackDate.toLocaleDateString() + ' ' + fallbackDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } else {
              date.textContent = msgDate.toLocaleDateString() + ' ' + msgDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }

            item.appendChild(from);
            item.appendChild(subject);
            item.appendChild(date);

            item.addEventListener('click', async () => {
              selectedMessage = msg;
              await renderMessageList(currentFolder);
              renderReadingPane(msg, folder);
            });

            messageList.appendChild(item);
          });
        }

        function renderReadingPane(msg, folder) {
          readingPane.innerHTML = '';
          
          if (!msg) {
            const emptyMsg = document.createElement('div');
            emptyMsg.style.padding = '12px';
            emptyMsg.style.color = 'var(--ink)';
            emptyMsg.textContent = 'Select a message to read.';
            readingPane.appendChild(emptyMsg);
            return;
          }

          // Scrollable content area
          const scrollableContent = document.createElement('div');
          scrollableContent.style.flex = '1';
          scrollableContent.style.minHeight = '0';
          scrollableContent.style.overflowY = 'auto';
          scrollableContent.style.padding = '12px';

          const header = document.createElement('div');
          header.style.marginBottom = '12px';
          header.style.paddingBottom = '8px';
          header.style.borderBottom = '1px solid var(--ink)';
          header.innerHTML = `
            <div><b>From:</b> ${msg.from}</div>
            <div style="margin-top: 4px;"><b>To:</b> ${msg.to || 'Lida'}</div>
            <div style="margin-top: 4px;"><b>Subject:</b> ${msg.subject || '(no subject)'}</div>
          `;

          const body = document.createElement('div');
          body.style.marginTop = '12px';
          body.style.whiteSpace = 'pre-wrap';
          body.style.fontFamily = 'var(--ui-font)';
          body.style.fontSize = '13px';
          body.style.lineHeight = '1.5';
          body.textContent = msg.body;

          scrollableContent.appendChild(header);
          scrollableContent.appendChild(body);
          readingPane.appendChild(scrollableContent);

          // Reply button area (fixed at bottom)
          if (folder === 'inbox' && msg.id === 'rodion_new') {
            const buttonArea = document.createElement('div');
            buttonArea.style.padding = '12px';
            buttonArea.style.borderTop = '1px solid var(--ink)';
            buttonArea.style.background = 'var(--bg-paper)';
            buttonArea.style.flexShrink = '0';

            const replyBtn = document.createElement('button');
            replyBtn.textContent = 'Reply ↩';
            replyBtn.style.cssText = 'border: 2px solid var(--ink); background: var(--bg-paper); padding: 10px 20px; cursor: pointer; font-family: var(--ui-font); font-size: 15px; font-weight: 700;';
            
            replyBtn.addEventListener('mouseenter', () => {
              replyBtn.style.background = '#E8E5E0';
            });
            replyBtn.addEventListener('mouseleave', () => {
              replyBtn.style.background = 'var(--bg-paper)';
            });
            
            replyBtn.addEventListener('click', () => {
              showReplyComposer(msg);
            });

            buttonArea.appendChild(replyBtn);
            readingPane.appendChild(buttonArea);
          }

          // Mark as read if inbox message
          if (folder === 'inbox' && msg.unread) {
            markAsRead(msg.id);
            msg.unread = false;
            updateUnreadBadge();
          }
        }

        function showReplyComposer(originalMsg) {
          readingPane.innerHTML = '';
          
          const composer = document.createElement('div');
          composer.innerHTML = `
            <div style="margin-bottom: 12px;"><b>Reply to:</b> ${originalMsg.from}</div>
            <div style="margin-bottom: 8px;">
              <label style="display: block; margin-bottom: 4px;"><b>To:</b></label>
              <input type="text" id="replyTo" value="${originalMsg.from}" readonly style="width: 100%; padding: 6px; border: 1px solid var(--ink); font-family: var(--ui-font); font-size: 13px; background: #E8E5E0;">
  </div>
            <div style="margin-bottom: 8px;">
              <label style="display: block; margin-bottom: 4px;"><b>Subject:</b></label>
              <input type="text" id="replySubject" value="Re: ${originalMsg.subject}" style="width: 100%; padding: 6px; border: 1px solid var(--ink); font-family: var(--ui-font); font-size: 13px; background: var(--bg-paper);">
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; margin-bottom: 4px;"><b>Body:</b></label>
              <textarea id="replyBody" rows="8" style="width: 100%; padding: 6px; border: 1px solid var(--ink); font-family: var(--ui-font); font-size: 13px; resize: vertical; background: var(--bg-paper);"></textarea>
            </div>
            <div style="display: flex; gap: 8px;">
              <button id="sendReply" style="border: 1px solid var(--ink); background: var(--bg-paper); padding: 8px 16px; cursor: pointer; font-family: var(--ui-font); font-size: 14px; font-weight: 700;">Send</button>
              <button id="cancelReply" style="border: 1px solid var(--ink); background: var(--bg-paper); padding: 8px 16px; cursor: pointer; font-family: var(--ui-font); font-size: 14px;">Cancel</button>
            </div>
            <div id="replyStatus" style="margin-top: 12px; font-size: 12px;"></div>
          `;

          readingPane.appendChild(composer);

          const sendBtn = composer.querySelector('#sendReply');
          const cancelBtn = composer.querySelector('#cancelReply');
          const status = composer.querySelector('#replyStatus');

          sendBtn.addEventListener('click', async () => {
            const to = composer.querySelector('#replyTo').value;
            const subject = composer.querySelector('#replySubject').value;
            const body = composer.querySelector('#replyBody').value.trim();

            if (!body) {
              status.textContent = 'Body cannot be empty.';
              status.style.color = 'var(--ink)';
              return;
            }

            const newMessage = {
              from: 'Lida (Narratoscope)',
              to: to,
              subject: subject,
              body: body
            };

            // Disable button and show "Sending..."
            sendBtn.disabled = true;
            sendBtn.textContent = 'Sending...';
            status.textContent = '';
            status.style.color = 'var(--ink)';

            try {
              await saveOutboxMessage(newMessage);
              
              // Mark original as read
              markAsRead(originalMsg.id);
              originalMsg.unread = false;
              updateUnreadBadge();

              status.textContent = 'Sent.';
              status.style.color = 'var(--ink)';

              // Refresh Outbox and clear composer after a moment
              setTimeout(async () => {
                if (currentFolder === 'outbox') {
                  await renderMessageList('outbox');
                  const serverMessages = await getOutboxMessages();
                  if (serverMessages.length > 0) {
                    renderReadingPane(serverMessages[0], 'outbox');
                  }
                } else {
                  renderReadingPane(originalMsg, 'inbox');
                }
              }, 1000);
            } catch (e) {
              status.textContent = 'Send failed.';
              status.style.color = 'var(--ink)';
              sendBtn.disabled = false;
              sendBtn.textContent = 'Send';
            }
          });

          cancelBtn.addEventListener('click', () => {
            renderReadingPane(originalMsg, 'inbox');
          });
        }

        // Folder switching
        inboxBtn.addEventListener('click', () => {
          currentFolder = 'inbox';
          selectedMessage = null;
          inboxBtn.style.fontWeight = '700';
          outboxBtn.style.fontWeight = '400';
          renderMessageList('inbox');
          renderReadingPane(null, 'inbox');
        });

        outboxBtn.addEventListener('click', async () => {
          currentFolder = 'outbox';
          selectedMessage = null;
          inboxBtn.style.fontWeight = '400';
          outboxBtn.style.fontWeight = '700';
          await renderMessageList('outbox');
          renderReadingPane(null, 'outbox');
        });

        // Initialize
        updateUnreadBadge();
        inboxBtn.style.fontWeight = '700';
        renderMessageList('inbox');
        renderReadingPane(null, 'inbox');

        DesktopCore.spawnWindow({ title: 'Mailbox', width: 800, height: 600, content: wrap });
      }
    });

    /* МОДУЛЬ: Photos */
    DesktopCore.register({ id: 'photos', title: 'Photos', iconClass: '', iconUrl: 'assets/icons/journal.png',
      onOpen() {
        const photos = [
          'office_night.jpg',
          'coffee_spill.jpg',
          'window_reflection.jpg'
        ];

        const wrap = document.createElement('div');
        const grid = document.createElement('div');
        grid.style.display = 'grid';
        grid.style.gridTemplateColumns = 'repeat(auto-fill, 140px)';
        grid.style.gap = '20px';

        photos.forEach(photoName => {
          const cell = document.createElement('div');
          cell.style.width = '140px';
          cell.style.textAlign = 'center';
          cell.style.userSelect = 'none';
          cell.style.cursor = 'pointer';

          const ico = document.createElement('div');
          ico.style.width = '120px';
          ico.style.height = '120px';
          ico.style.margin = '0 auto';
          if (photoName === 'office_night.jpg') {
            ico.style.backgroundColor = '#ccc';
            ico.style.border = '2px solid var(--ink)';
            ico.style.overflow = 'hidden';
            const thumb = document.createElement('img');
            thumb.src = 'assets/office_night.png';
            thumb.style.width = '100%';
            thumb.style.height = '100%';
            thumb.style.objectFit = 'cover';
            thumb.style.display = 'block';
            thumb.style.imageRendering = 'pixelated';
            ico.appendChild(thumb);
          } else {
            ico.style.backgroundColor = '#ccc';
            ico.style.border = '2px solid var(--ink)';
            ico.style.display = 'grid';
            ico.style.placeItems = 'center';
            ico.style.fontSize = '32px';
            ico.textContent = '?';
          }

          const cap = document.createElement('div');
          cap.textContent = photoName;
          cap.className = 'folder-file-label';
          cap.style.marginTop = '8px';
          cap.style.fontSize = '12px';

          cell.addEventListener('click', () => {
            let content;
            if (photoName === 'office_night.jpg') {
              const container = document.createElement('div');
              container.style.height = '100%';
              container.style.width = '100%';
              container.style.padding = '0';
              container.style.margin = '0';
              container.style.boxSizing = 'border-box';
              
              const img = document.createElement('img');
              img.src = 'assets/office_night.png';
              img.style.width = '100%';
              img.style.height = '100%';
              img.style.objectFit = 'cover';
              img.style.display = 'block';
              img.style.imageRendering = 'pixelated';
              img.alt = photoName;
              
              img.onerror = () => {
                container.innerHTML = '';
                container.style.fontFamily = 'var(--ui-font)';
                container.style.fontSize = '14px';
                container.style.textAlign = 'center';
                container.style.padding = '40px';
                container.innerHTML = '<div style="font-size: 48px; margin-bottom: 20px;">⚠</div><p><b>Failed to load image.</b></p><p style="margin-top: 10px; font-size: 12px; color: #666;">assets/office_night.png</p>';
              };
              
              container.appendChild(img);
              content = container;
              
              // Calculate 30% smaller (70% of original size)
              const photoWidth = Math.round(1200 * 0.7);
              const photoHeight = Math.round(900 * 0.7);
              
              // Ensure it doesn't exceed viewport
              const desktopEl = document.querySelector('.desktop');
              const maxWidth = desktopEl ? desktopEl.clientWidth - 24 : photoWidth;
              const maxHeight = desktopEl ? desktopEl.clientHeight - 24 : photoHeight;
              
              DesktopCore.spawnWindow({
                title: photoName,
                width: Math.min(photoWidth, maxWidth),
                height: Math.min(photoHeight, maxHeight),
                content: content
              });
            } else {
              content = `<div style="font-family: var(--ui-font); font-size: 14px; text-align: center; padding: 40px;">
                <div style="font-size: 48px; margin-bottom: 20px;">⚠</div>
                <p><b>File corrupted or removed.</b></p>
              </div>`;
              DesktopCore.spawnWindow({
                title: photoName,
                width: 400,
                height: 300,
                content: content
              });
            }
          });

          cell.appendChild(ico);
          cell.appendChild(cap);
          grid.appendChild(cell);
        });

        wrap.appendChild(grid);
        DesktopCore.spawnWindow({ title: 'Photos', width: 520, height: 420, content: wrap });
      }
    });


    /* МОДУЛЬ: Trash */
    (() => {
      let trashFileRestored = false; // Track if file has been restored

      // Document file in Trash (defined in closure scope for restored icon access)
      const trashFile = {
        name: 'editorial_v2.doc',
        content: `# What Deserves to Be Printed?
## (or: why the hell am I starting a magazine in 2026?)

**[Note to self: too defensive? start with the question directly?]**

Everything is online. Everything is instant. Everything is... everywhere, all at once, forever. So why print?

**[margin note: "this sounds pretentious - be funnier here"]**

Here's what I know: I've read 47 articles this week. I remember exactly one sentence from one of them. Maybe two if I'm being generous. The rest? Gone. Dissolved into the infinite scroll, the algorithmic void, the digital whatever-we're-calling-it-now.

But last month I found a magazine from 1987 in my grandmother's attic. Cover curled, pages yellowed, smelling like time itself. And I read every single word. ~~Why? Because it was there? Because~~

**[margin note: "get to the point faster"]**

Print demands something. It demands: *is this worth the paper it's printed on?* And that's not poetic bullshit—that's literal. Paper costs money. Ink costs money. ~~Distribution costs money. Someone has to physically carry this thing from~~ 

The internet lets us publish anything. (And god knows we do.) But print? Print makes you choose. 

So what deserves it?

~~Not everything that goes viral. Not everything that gets engagement. Not~~

**[margin note: "what DOES deserve it then???? answer this or delete everything"]**

Maybe it's this: the stuff you'd want to find in *your* grandmother's attic in 40 years. The stuff that doesn't just capture *this exact moment* but... 

**[margin note: "finish this thought or I swear to god"]**

Look, I don't have all the answers. I'm literally sitting here in my apartment trying to justify why I'm about to spend [redacted amount] ~~of money I definitely don't have~~ on printing something that anyone could just... post. For free. Right now.

But here's the thing—

**[margin note: "here's WHAT thing???"]**

~~I think we've confused~~ When everything lives forever online, nothing really lives at all. It's all just... *there*. Floating. Waiting to be dug up in some future context collapse where your 2015 tweet about sandwich preferences somehow ruins your career.

Print is different. Print is a commitment. Print says: **this mattered enough.**

And maybe that's all a magazine needs to be now. Not a format. Not a business model. Just a filter. A curatorial middle finger to the idea that everything deserves equal attention just because it can technically reach everyone.

~~So if you're reading this~~

**[final margin note: "DO I CUT THE ENDING OR DOES IT NEED ONE? also - is this whole thing stupid? also also - call Marcus about printing costs. also also also - WHY AM I DOING THIS"]`
      };

      // Convert markdown-like content to HTML (process line by line)
      function formatLine(line) {
        let html = line;
          // Convert headers first
          if (html.match(/^### (.+)$/)) {
            html = '<h3>' + html.replace(/^### (.+)$/, '$1') + '</h3>';
          } else if (html.match(/^## (.+)$/)) {
            html = '<h2>' + html.replace(/^## (.+)$/, '$1') + '</h2>';
          } else if (html.match(/^# (.+)$/)) {
            html = '<h1>' + html.replace(/^# (.+)$/, '$1') + '</h1>';
          } else {
            // Convert strikethrough ~~text~~ to <s>text</s>
            html = html.replace(/~~([^~]+)~~/g, '<s>$1</s>');
            // Convert margin notes **[margin note: "..."]** to styled notes
            html = html.replace(/\*\*\[margin note: "([^"]+)"\]\*\*/g, '<span style="font-style: italic; color: #666;">[margin note: "$1"]</span>');
            // Convert **[Note to self: ...]** to styled notes
            html = html.replace(/\*\*\[Note to self: ([^\]]+)\]\*\*/g, '<span style="font-style: italic; color: #666;">[Note to self: $1]</span>');
            // Convert **[final margin note: ...]** to styled notes
            html = html.replace(/\*\*\[final margin note: "([^"]+)"\]\*\*/g, '<span style="font-style: italic; color: #666;">[final margin note: "$1"]</span>');
            // Convert **bold** to <strong>
            html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            // Convert *italic* to <em> (single asterisk, not double)
            html = html.replace(/(^|[^*])\*([^*]+)\*([^*]|$)/g, '$1<em>$2</em>$3');
        }
        return html;
      }

      function createDocumentWindow() {
        const docWrap = document.createElement('div');
        docWrap.style.fontFamily = 'var(--ui-font)';
        docWrap.style.fontSize = '14px';
        docWrap.style.height = '100%';
        docWrap.style.display = 'flex';
        docWrap.style.flexDirection = 'column';
        docWrap.style.padding = '16px';
        docWrap.style.boxSizing = 'border-box';

        // Two-column container
        const columnsContainer = document.createElement('div');
        columnsContainer.style.display = 'flex';
        columnsContainer.style.flex = '1';
        columnsContainer.style.gap = '20px';
        columnsContainer.style.minHeight = '0';
        columnsContainer.style.overflowY = 'auto';

        // Process content line by line
        const lines = trashFile.content.split('\n');
        const formattedLines = lines.map(line => formatLine(line));
        
        // Split roughly in half (find a good breaking point near the middle)
        const midPoint = Math.ceil(formattedLines.length / 2);
        // Try to break at an empty line if possible
        let breakPoint = midPoint;
        for (let i = midPoint - 5; i < midPoint + 5 && i < formattedLines.length; i++) {
          if (formattedLines[i].trim() === '' || formattedLines[i].trim() === '<br>') {
            breakPoint = i + 1;
            break;
          }
        }

        // First column
        const col1 = document.createElement('div');
        col1.style.width = '50%';
        col1.style.display = 'flex';
        col1.style.flexDirection = 'column';
        col1.style.paddingRight = '10px';

        // Image at top of first column
        const img = document.createElement('img');
        img.src = 'assets/icons/printing.png';
        img.style.width = '100%';
        img.style.height = 'auto';
        img.style.imageRendering = 'pixelated';
        img.style.marginBottom = '16px';
        col1.appendChild(img);

        // Content (first half)
        const contentDiv1 = document.createElement('div');
        contentDiv1.style.lineHeight = '1.6';
        contentDiv1.innerHTML = formattedLines.slice(0, breakPoint).join('<br>');
        col1.appendChild(contentDiv1);

        // Second column
        const col2 = document.createElement('div');
        col2.style.width = '50%';
        col2.style.display = 'flex';
        col2.style.flexDirection = 'column';
        col2.style.paddingLeft = '10px';

        // Content (second half)
        const contentDiv2 = document.createElement('div');
        contentDiv2.style.lineHeight = '1.6';
        contentDiv2.innerHTML = formattedLines.slice(breakPoint).join('<br>');
        col2.appendChild(contentDiv2);

        columnsContainer.appendChild(col1);
        columnsContainer.appendChild(col2);

        // Footer
        const footer = document.createElement('div');
        footer.style.marginTop = '16px';
        footer.style.paddingTop = '12px';
        footer.style.borderTop = '1px solid var(--ink)';
        footer.style.fontSize = '12px';
        footer.style.color = '#666';
        footer.textContent = 'editorial_v2.doc | Last modified: 2:34 AM | Location: Trash';

        docWrap.appendChild(columnsContainer);
        docWrap.appendChild(footer);

        return docWrap;
      }

      DesktopCore.register({ id: 'trash', title: 'Trash', iconClass: '', iconUrl: 'assets/icons/trash.png',
        onOpen() {
          // Don't show file if it's already been restored
          if (trashFileRestored) {
            const wrap = document.createElement('div');
            wrap.style.fontFamily = 'var(--ui-font)';
            wrap.style.fontSize = '14px';
            wrap.style.padding = '20px';
            wrap.textContent = 'Trash is empty.';
            DesktopCore.spawnWindow({ title: 'Trash', width: 520, height: 420, content: wrap });
            return;
          }

          const wrap = document.createElement('div');
          wrap.style.fontFamily = 'var(--ui-font)';
          wrap.style.fontSize = '14px';

          const grid = document.createElement('div');
          grid.style.display = 'grid';
          grid.style.gridTemplateColumns = 'repeat(auto-fill, 120px)';
          grid.style.gap = '16px';

          const cell = document.createElement('div');
          cell.style.width = '120px';
          cell.style.textAlign = 'center';
          cell.style.userSelect = 'none';
          cell.style.cursor = 'default'; // No open action

          const ico = document.createElement('div');
          ico.style.width = '96px';
          ico.style.height = '96px';
          ico.style.margin = '0 auto';
          ico.style.backgroundImage = `url('assets/icons/txt.png')`;
          ico.style.backgroundRepeat = 'no-repeat';
          ico.style.backgroundPosition = 'center';
          ico.style.backgroundSize = 'contain';
          ico.style.imageRendering = 'pixelated';

          const cap = document.createElement('div');
          cap.textContent = trashFile.name;
          cap.className = 'folder-file-label';
          cap.style.marginTop = '6px';
          cap.style.fontSize = '12px';

          // Right-click context menu for Restore (only action allowed)
          cell.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            DesktopCore.showContext(e.clientX, e.clientY, [
              { 
                label: 'Restore', 
                action: () => {
                  // Mark as restored
                  trashFileRestored = true;
                  
                  // Calculate bottom-left position
                  const deskEl = document.querySelector('.desktop');
                  const root = getComputedStyle(document.documentElement);
                  const ICON = parseInt(root.getPropertyValue('--icon-size')) || 180;
                  const PAD = 24;
                  const maxH = deskEl ? deskEl.clientHeight : window.innerHeight;
                  
                  // Position near bottom-left corner
                  const bottomLeftPos = {
                    x: PAD,
                    y: maxH - ICON - PAD
                  };
                  
                  // Restore: create desktop icon
                  const pos = DesktopCore.getIconPosition('restored_' + trashFile.name, bottomLeftPos);
                  const iconEl = DesktopCore.spawnIcon({
                    id: 'restored_' + trashFile.name,
                    title: trashFile.name,
                    className: '',
                    iconUrl: 'assets/icons/txt.png',
                    x: pos.x,
                    y: pos.y,
                    onOpen() {
                      const docContent = createDocumentWindow();
                      DesktopCore.spawnWindow({
                        title: trashFile.name,
                        width: 800,
                        height: 600,
                        content: docContent
                      });
                    }
                  });
                  
                  // Ensure icon is not in selected state and uses default label styling
                  iconEl.classList.remove('selected');
                  
                  // Remove from Trash (remove the cell)
                  cell.remove();
                }
              }
            ], cell);
          });

          cell.appendChild(ico);
          cell.appendChild(cap);
          grid.appendChild(cell);

          wrap.appendChild(grid);
          DesktopCore.spawnWindow({ title: 'Trash', width: 520, height: 420, content: wrap });
        }
      });
    })();

    // Порядок появления иконок (фиксированный)
const layout = [
      'my-computer',    // My Computer
      'inbox',          // Inbox (Mailbox)
      'drafts',         // Drafts
      'photos',         // Photos
      'expenses',       // Expenses.xlsx
      'do-not-open',    // do_not_open.txt
      'publishing-cheat-sheet', // CHEAT_SHEET.txt
      'trash'           // Trash
];

    function bootSequence() {
      const bootEl = document.getElementById('boot');
      bootEl.classList.remove('hidden');
      const bar = document.getElementById('bootbar'); 
      let p = 0; 
      const t = setInterval(() => { 
        p += Math.random()*18; 
        if (p >= 100) { 
          p = 100; 
          clearInterval(t); 
          bootEl.classList.add('hidden'); 
        } 
        bar.style.width = p + '%'; 
      }, 220);
    }

    // Применяем стартовый фон
    function applyInitialWallpaper(){
      // WP_INDEX не используется, так как обои применяются через CSS
      // Функция оставлена для совместимости
      applyWallpaper();
    }
    
    // Единая функция для детерминированного перехода на рабочий стол
    function enterDesktop() {
      try {
        // Скрываем экран пароля (самое важное - сделать это сразу)
        if (passwordScreen) {
          passwordScreen.classList.add('hidden');
        }
        
        // Запускаем boot sequence (анимация загрузки) - если функция доступна
        if (typeof bootSequence === 'function') {
          try {
            bootSequence();
          } catch (e) {
            console.error('Error in bootSequence:', e);
            // Продолжаем даже если boot sequence не работает
          }
        }
        
        // Инициализируем рабочий стол и применяем обои
        // Надежный подход для Safari с несколькими попытками
        let initAttempts = 0;
        const maxAttempts = 15;
        
        const tryInitDesktop = () => {
          try {
            const deskEl = document.querySelector('.desktop');
            if (!deskEl) {
              if (initAttempts < maxAttempts) {
                initAttempts++;
                setTimeout(tryInitDesktop, 100);
              }
              return;
            }
            
            // Проверяем, что иконки еще не созданы
            if (deskEl.querySelectorAll('.icon').length > 0) {
              return; // Уже созданы
            }
            
            // Проверяем, что DesktopCore готов (более мягкая проверка для Safari)
            if (typeof DesktopCore === 'undefined' || !DesktopCore || !DesktopCore.registry) {
              if (initAttempts < maxAttempts) {
                initAttempts++;
                setTimeout(tryInitDesktop, 100);
              }
              return;
            }
            
            // Проверяем, что есть хотя бы несколько модулей (не обязательно все)
            if (DesktopCore.registry.size < 3) {
              if (initAttempts < maxAttempts) {
                initAttempts++;
                setTimeout(tryInitDesktop, 100);
              }
              return;
            }
            
            // Все готово - инициализируем
            if (typeof initDesktop === 'function') {
              initDesktop();
            }
            if (typeof applyInitialWallpaper === 'function') {
              applyInitialWallpaper();
            }
          } catch (err) {
            console.error('Error initializing desktop:', err);
            if (initAttempts < maxAttempts) {
              initAttempts++;
              setTimeout(tryInitDesktop, 150);
            }
          }
        };
        
        // Запускаем инициализацию с задержкой для Safari
        setTimeout(() => {
          tryInitDesktop();
        }, 300);
      } catch (err) {
        console.error('Error entering desktop:', err);
        // Последний fallback: просто скрываем password screen
        if (passwordScreen) {
          passwordScreen.classList.add('hidden');
        }
      }
    }

    function initDesktop() {
      try {
        // Проверяем, что DesktopCore доступен
        if (typeof DesktopCore === 'undefined' || !DesktopCore || !DesktopCore.registry) {
          return;
        }
        
      const deskEl = document.querySelector('.desktop');
        if (!deskEl) {
          return;
        }
        
        // Защита от дублирования: проверяем, не созданы ли уже иконки
        if (deskEl.querySelectorAll('.icon').length > 0) {
          return;
        }
        
        const maxW = deskEl.clientWidth;
        const maxH = deskEl.clientHeight;
      const root = getComputedStyle(document.documentElement);
      const ICON = parseInt(root.getPropertyValue('--icon-size')) || 180;
      const PAD = 24; // внутренний отступ от краёв

        // Helper: ограничение координат в пределах видимой области
        const clamp = (val, min, max) => Math.max(min, Math.min(max, val));

        // Проверяем, что layout определен
        if (!layout || !Array.isArray(layout)) {
          console.error('Layout not defined');
          return;
        }

        // Разделяем иконки на топ-ряд и trash
        const topRowIds = layout.filter(id => id !== 'trash');
        const trashId = layout.find(id => id === 'trash');

        // Вычисляем позиции для топ-ряда (равномерно распределены)
        const topRowY = PAD + 12; // 12px от верха
        const availableWidth = maxW - 2 * PAD;
        const step = topRowIds.length > 1 ? availableWidth / topRowIds.length : 0;

        // Размещаем иконки топ-ряда
        topRowIds.forEach((id, index) => {
          try {
            const mod = DesktopCore.registry.get(id);
            if (!mod) {
              console.warn('Module not found:', id);
              return;
            }

        const saved = DesktopCore.getIconPosition(id, null);
            let pos;

            if (saved) {
              // Используем сохраненную позицию с ограничением
              pos = {
                x: clamp(saved.x, PAD, maxW - ICON - PAD),
                y: clamp(saved.y, PAD, maxH - ICON - PAD)
              };
            } else {
              // Новая позиция: равномерно распределены в топ-ряду
              const centerX = PAD + index * step + step / 2;
              pos = {
                x: clamp(Math.round(centerX - ICON / 2), PAD, maxW - ICON - PAD),
                y: topRowY
              };
            }

            DesktopCore.spawnIcon({
              id: mod.id,
              title: mod.title,
              className: mod.iconClass,
              iconUrl: mod.iconUrl,
              x: pos.x,
              y: pos.y,
              onOpen: mod.onOpen,
              contextItems: mod.contextItems
            });
          } catch (err) {
            console.error('Error creating icon for', id, ':', err);
          }
        });

        // Размещаем Trash в правом нижнем углу
        if (trashId) {
          try {
            const mod = DesktopCore.registry.get(trashId);
            if (mod) {
              const saved = DesktopCore.getIconPosition(trashId, null);
              let pos;

              if (saved) {
                // Используем сохраненную позицию с ограничением
                pos = {
                  x: clamp(saved.x, PAD, maxW - ICON - PAD),
                  y: clamp(saved.y, PAD, maxH - ICON - PAD)
                };
              } else {
                // Новая позиция: правый нижний угол
                pos = {
                  x: maxW - ICON - PAD,
                  y: maxH - ICON - PAD
                };
              }

              DesktopCore.spawnIcon({
                id: mod.id,
                title: mod.title,
                className: mod.iconClass,
                iconUrl: mod.iconUrl,
                x: pos.x,
                y: pos.y,
                onOpen: mod.onOpen,
                contextItems: mod.contextItems
              });
            }
          } catch (err) {
            console.error('Error creating trash icon:', err);
          }
        }
      } catch (err) {
        console.error('Error in initDesktop:', err);
      }
    }

    /* ===== Password Screen ===== */
    const PASSWORD_WORDS = ['love', 'pretend', 'imagine'];
    const passwordScreen = document.getElementById('passwordScreen');
    const passwordInputs = ['pwd1', 'pwd2', 'pwd3'].map(id => document.getElementById(id));
    const passwordSubmit = document.getElementById('passwordSubmit');
    const passwordError = document.getElementById('passwordError');

    function checkPassword() {
      try {
        // Локально определяем поля ввода, чтобы исключить ReferenceError в Safari
        const passwordInputs = [
          document.getElementById('pwd1'),
          document.getElementById('pwd2'),
          document.getElementById('pwd3')
        ];
        // Безопасная проверка наличия элементов
        if (!passwordInputs || passwordInputs.length === 0) {
          console.error('Password inputs not found');
          return;
        }
        
        // Защита от отсутствия PASSWORD_WORDS в Safari
        const words = (typeof PASSWORD_WORDS !== 'undefined' && Array.isArray(PASSWORD_WORDS))
          ? PASSWORD_WORDS
          : ['love', 'pretend', 'imagine'];

        const values = passwordInputs.map(inp => inp ? inp.value.trim().toLowerCase() : '');
        const correct = words.every((word, i) => values[i] === word);
        
        if (correct) {
          // Всегда вызываем enterDesktop, даже если есть ошибки внутри
          if (typeof enterDesktop === 'function') {
            enterDesktop();
          } else {
            // Fallback: если функция не определена, просто скрываем экран пароля
            console.error('enterDesktop function not found, using fallback');
            if (passwordScreen) passwordScreen.classList.add('hidden');
          }
        } else {
          if (passwordError) passwordError.textContent = 'Incorrect password. Please try again.';
          passwordInputs.forEach(inp => { 
            if (inp) {
              inp.value = ''; 
              inp.style.borderColor = '#9b0000'; 
            }
          });
          setTimeout(() => {
            passwordInputs.forEach(inp => { 
              if (inp) inp.style.borderColor = 'var(--ink)'; 
            });
            if (passwordError) passwordError.textContent = '';
          }, 2000);
          if (passwordInputs[0]) passwordInputs[0].focus();
        }
      } catch (err) {
        // В случае ошибки все равно пытаемся перейти на рабочий стол
        console.error('Error in checkPassword:', err);
        // Не показываем ошибку пользователю, вместо этого пытаемся продолжить
        if (typeof enterDesktop === 'function') {
          try {
            enterDesktop();
          } catch (e) {
            console.error('Error in enterDesktop fallback:', e);
            // Последний fallback: просто скрываем экран пароля
            if (passwordScreen) passwordScreen.classList.add('hidden');
          }
        } else {
          if (passwordScreen) passwordScreen.classList.add('hidden');
        }
      }
    }

    passwordSubmit.addEventListener('click', checkPassword);
    passwordInputs.forEach((inp, i) => {
      // Используем keydown вместо keypress для лучшей совместимости (особенно на Mac)
      inp.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.keyCode === 13) {
          e.preventDefault(); // Предотвращаем стандартное поведение
          if (i < passwordInputs.length - 1) {
            passwordInputs[i + 1].focus();
          } else {
            checkPassword();
          }
        }
      });
    });
    // Фокусируемся на первом поле только если оно существует
    if (passwordInputs[0]) {
      passwordInputs[0].focus();
    }
    } // end if (!isMobileDevice)
  </script>




